<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/hooks/useRoadmaps.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hooks/useRoadmaps.tsx" />
              <option name="originalContent" value="import { useState, useEffect } from 'react';&#10;import { Roadmap } from '@/shared/types';&#10;&#10;interface UseRoadmapsOptions {&#10;    searchTerm?: string;&#10;    domain?: string;&#10;    sortBy?: 'title' | 'created_at';&#10;    sortOrder?: 'asc' | 'desc';&#10;}&#10;&#10;// Mock data for development&#10;const mockRoadmaps: Roadmap[] = [&#10;    {&#10;        id: 1,&#10;        title: &quot;Frontend Development Mastery&quot;,&#10;        description: &quot;Complete journey from HTML basics to advanced React patterns and modern CSS techniques.&quot;,&#10;        domain: &quot;Frontend&quot;,&#10;        status: &quot;In Progress&quot;,&#10;        created_at: &quot;2024-01-15T10:30:00Z&quot;,&#10;        estimated_duration: &quot;6-8 months&quot;,&#10;        progress: 45,&#10;    },&#10;    {&#10;        id: 2,&#10;        title: &quot;Backend API Development&quot;,&#10;        description: &quot;Learn to build robust REST APIs and GraphQL services with Node.js and Python.&quot;,&#10;        domain: &quot;Backend&quot;,&#10;        status: &quot;Completed&quot;,&#10;        created_at: &quot;2024-01-10T14:20:00Z&quot;,&#10;        estimated_duration: &quot;4-6 months&quot;,&#10;        progress: 100,&#10;    },&#10;    {&#10;        id: 3,&#10;        title: &quot;DevOps &amp; Cloud Infrastructure&quot;,&#10;        description: &quot;Master Docker, Kubernetes, AWS, and CI/CD pipelines for scalable deployments.&quot;,&#10;        domain: &quot;DevOps&quot;,&#10;        status: &quot;Draft&quot;,&#10;        created_at: &quot;2024-01-20T09:15:00Z&quot;,&#10;        estimated_duration: &quot;5-7 months&quot;,&#10;        progress: 0,&#10;    },&#10;    {&#10;        id: 4,&#10;        title: &quot;Mobile App Development&quot;,&#10;        description: &quot;Build cross-platform mobile apps with React Native and Flutter.&quot;,&#10;        domain: &quot;Mobile&quot;,&#10;        status: &quot;In Progress&quot;,&#10;        created_at: &quot;2024-01-12T16:45:00Z&quot;,&#10;        estimated_duration: &quot;3-5 months&quot;,&#10;        progress: 30,&#10;    },&#10;    {&#10;        id: 5,&#10;        title: &quot;Data Science Fundamentals&quot;,&#10;        description: &quot;Learn Python, machine learning, statistics, and data visualization techniques.&quot;,&#10;        domain: &quot;Data Science&quot;,&#10;        status: &quot;Draft&quot;,&#10;        created_at: &quot;2024-01-18T11:30:00Z&quot;,&#10;        estimated_duration: &quot;8-12 months&quot;,&#10;        progress: 0,&#10;    },&#10;];&#10;&#10;export function useRoadmaps(options: UseRoadmapsOptions = {}) {&#10;    const [roadmaps, setRoadmaps] = useState&lt;Roadmap[]&gt;([]);&#10;    const [loading, setLoading] = useState(true);&#10;    const [error, setError] = useState&lt;string | null&gt;(null);&#10;    const [roadmapData, setRoadmapData] = useState&lt;Roadmap | null&gt;(null);&#10;// fetching roadmaps from mock data or API&#10;    async function getAllUserRoadmapsAPI(userId: string) {&#10;        try {&#10;            const response = await fetch(&quot;http://127.0.0.1:5000/getuser&quot;, {&#10;                method: &quot;POST&quot;,&#10;                headers: {&#10;                    &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;                },&#10;                body: JSON.stringify({ user_id: userId }), // send user_id&#10;            });&#10;&#10;            const {data} = await response.json();&#10;&#10;            if (!response.ok || !data) {&#10;                console.error(&quot;Error fetching user roadmaps:&quot;, data.message || &quot;Unknown error&quot;);&#10;                return null;&#10;            }&#10;&#10;            return data; // list of roadmaps&#10;        } catch (err) {&#10;            console.error(&quot;Fetch error:&quot;, err);&#10;            return null;&#10;        }&#10;    }&#10;&#10;// get profile from localStorage&#10;    let profile = null;&#10;    if (typeof window !== 'undefined') {&#10;        profile = localStorage.getItem(&quot;profile&quot;);&#10;    }&#10;    const p = JSON.parse(profile || &quot;{}&quot;);&#10;&#10;    useEffect(() =&gt; {&#10;        const fetchRoadmap = async () =&gt; {&#10;            const userRoadmaps = await getAllUserRoadmapsAPI(p.id);&#10;            if (userRoadmaps &amp;&amp; userRoadmaps.length &gt; 0) {&#10;                // Assuming you want the first roadmap for display&#10;                setRoadmapData(&#10;                    roadmapData.map(roadmap =&gt; ({...roadmap,user_id: p.id }) // Add user_id to each roadmap&#10;                ));&#10;                console.log(userRoadmaps);&#10;            } else {&#10;                setRoadmapData(null);&#10;            }&#10;            setLoading(false);&#10;        };&#10;        fetchRoadmap();&#10;    }, []);&#10;//&#10;    const fetchRoadmaps = async () =&gt; {&#10;        try {&#10;            setLoading(true);&#10;            &#10;            // Simulate API delay&#10;            await new Promise(resolve =&gt; setTimeout(resolve, 500));&#10;            &#10;            let filteredRoadmaps = [...roadmapData];&#10;&#10;            // Apply search filter&#10;            if (options.searchTerm) {&#10;                filteredRoadmaps = filteredRoadmaps.filter(roadmap =&gt;&#10;                    roadmap.title.toLowerCase().includes(options.searchTerm!.toLowerCase()) ||&#10;                    roadmap.description?.toLowerCase().includes(options.searchTerm!.toLowerCase())&#10;                );&#10;            }&#10;&#10;            // Apply domain filter&#10;            if (options.domain) {&#10;                filteredRoadmaps = filteredRoadmaps.filter(roadmap =&gt;&#10;                    roadmap.domain.toLowerCase() === options.domain!.toLowerCase()&#10;                );&#10;            }&#10;&#10;            // Apply sorting&#10;            if (options.sortBy) {&#10;                filteredRoadmaps.sort((a, b) =&gt; {&#10;                    const aValue = a[options.sortBy!];&#10;                    const bValue = b[options.sortBy!];&#10;                    &#10;                    if (options.sortOrder === 'desc') {&#10;                        return bValue &gt; aValue ? 1 : -1;&#10;                    }&#10;                    return aValue &gt; bValue ? 1 : -1;&#10;                });&#10;            }&#10;&#10;            setRoadmaps(filteredRoadmaps);&#10;            setError(null);&#10;        } catch (err) {&#10;            setError(err instanceof Error ? err.message : 'Failed to fetch roadmaps');&#10;        } finally {&#10;            setLoading(false);&#10;        }&#10;    };&#10;&#10;    const deleteRoadmap = async (id: number) =&gt; {&#10;        try {&#10;            // Simulate API delay&#10;            await new Promise(resolve =&gt; setTimeout(resolve, 300));&#10;            &#10;            setRoadmaps(prev =&gt; prev.filter(roadmap =&gt; roadmap.id !== id));&#10;        } catch (err) {&#10;            setError(err instanceof Error ? err.message : 'Failed to delete roadmap');&#10;        }&#10;    };&#10;&#10;    const duplicateRoadmap = async (id: number) =&gt; {&#10;        try {&#10;            // Simulate API delay&#10;            await new Promise(resolve =&gt; setTimeout(resolve, 300));&#10;            &#10;            const roadmapToDuplicate = roadmaps.find(r =&gt; r.id === id);&#10;            if (roadmapToDuplicate) {&#10;                const newRoadmap: Roadmap = {&#10;                    ...roadmapToDuplicate,&#10;                    id: Math.max(...roadmaps.map(r =&gt; r.id)) + 1,&#10;                    title: `${roadmapToDuplicate.title} (Copy)`,&#10;                    status: 'Draft',&#10;                    created_at: new Date().toISOString(),&#10;                    progress: 0,&#10;                };&#10;                setRoadmaps(prev =&gt; [...prev, newRoadmap]);&#10;            }&#10;        } catch (err) {&#10;            setError(err instanceof Error ? err.message : 'Failed to duplicate roadmap');&#10;        }&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        fetchRoadmaps();&#10;    }, [options.searchTerm, options.domain, options.sortBy, options.sortOrder]);&#10;&#10;    return {&#10;        roadmaps,&#10;        loading,&#10;        error,&#10;        refetch: fetchRoadmaps,&#10;        deleteRoadmap,&#10;        duplicateRoadmap,&#10;    };&#10;}&#10;" />
              <option name="updatedContent" value="import { useState, useEffect } from 'react';&#10;import { Roadmap } from '@/shared/types';&#10;&#10;interface UseRoadmapsOptions {&#10;    searchTerm?: string;&#10;    domain?: string;&#10;    sortBy?: 'title' | 'created_at';&#10;    sortOrder?: 'asc' | 'desc';&#10;}&#10;&#10;// Mock data for development&#10;const mockRoadmaps: Roadmap[] = [&#10;    {&#10;        id: 1,&#10;        title: &quot;Frontend Development Mastery&quot;,&#10;        description: &quot;Complete journey from HTML basics to advanced React patterns and modern CSS techniques.&quot;,&#10;        domain: &quot;Frontend&quot;,&#10;        status: &quot;In Progress&quot;,&#10;        created_at: &quot;2024-01-15T10:30:00Z&quot;,&#10;        estimated_duration: &quot;6-8 months&quot;,&#10;        progress: 45,&#10;    },&#10;    {&#10;        id: 2,&#10;        title: &quot;Backend API Development&quot;,&#10;        description: &quot;Learn to build robust REST APIs and GraphQL services with Node.js and Python.&quot;,&#10;        domain: &quot;Backend&quot;,&#10;        status: &quot;Completed&quot;,&#10;        created_at: &quot;2024-01-10T14:20:00Z&quot;,&#10;        estimated_duration: &quot;4-6 months&quot;,&#10;        progress: 100,&#10;    },&#10;    {&#10;        id: 3,&#10;        title: &quot;DevOps &amp; Cloud Infrastructure&quot;,&#10;        description: &quot;Master Docker, Kubernetes, AWS, and CI/CD pipelines for scalable deployments.&quot;,&#10;        domain: &quot;DevOps&quot;,&#10;        status: &quot;Draft&quot;,&#10;        created_at: &quot;2024-01-20T09:15:00Z&quot;,&#10;        estimated_duration: &quot;5-7 months&quot;,&#10;        progress: 0,&#10;    },&#10;    {&#10;        id: 4,&#10;        title: &quot;Mobile App Development&quot;,&#10;        description: &quot;Build cross-platform mobile apps with React Native and Flutter.&quot;,&#10;        domain: &quot;Mobile&quot;,&#10;        status: &quot;In Progress&quot;,&#10;        created_at: &quot;2024-01-12T16:45:00Z&quot;,&#10;        estimated_duration: &quot;3-5 months&quot;,&#10;        progress: 30,&#10;    },&#10;    {&#10;        id: 5,&#10;        title: &quot;Data Science Fundamentals&quot;,&#10;        description: &quot;Learn Python, machine learning, statistics, and data visualization techniques.&quot;,&#10;        domain: &quot;Data Science&quot;,&#10;        status: &quot;Draft&quot;,&#10;        created_at: &quot;2024-01-18T11:30:00Z&quot;,&#10;        estimated_duration: &quot;8-12 months&quot;,&#10;        progress: 0,&#10;    },&#10;];&#10;&#10;export function useRoadmaps(options: UseRoadmapsOptions = {}) {&#10;    const [roadmaps, setRoadmaps] = useState&lt;Roadmap[]&gt;([]);&#10;    const [loading, setLoading] = useState(true);&#10;    const [error, setError] = useState&lt;string | null&gt;(null);&#10;    const [roadmapData, setRoadmapData] = useState&lt;Roadmap | null&gt;(null);&#10;// fetching roadmaps from mock data or API&#10;    async function getAllUserRoadmapsAPI(userId: string) {&#10;        try {&#10;            const response = await fetch(&quot;http://127.0.0.1:5000/getuser&quot;, {&#10;                method: &quot;POST&quot;,&#10;                headers: {&#10;                    &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;                },&#10;                body: JSON.stringify({ user_id: userId }), // send user_id&#10;            });&#10;&#10;            const {data} = await response.json();&#10;&#10;            if (!response.ok || !data) {&#10;                console.error(&quot;Error fetching user roadmaps:&quot;, data.message || &quot;Unknown error&quot;);&#10;                return null;&#10;            }&#10;&#10;            return data; // list of roadmaps&#10;        } catch (err) {&#10;            console.error(&quot;Fetch error:&quot;, err);&#10;            return null;&#10;        }&#10;    }&#10;&#10;// get profile from localStorage&#10;    let profile = null;&#10;    if (typeof window !== 'undefined') {&#10;        profile = localStorage.getItem(&quot;profile&quot;);&#10;    }&#10;    const p = JSON.parse(profile || &quot;{}&quot;);&#10;&#10;    useEffect(() =&gt; {&#10;        const fetchRoadmap = async () =&gt; {&#10;            const userRoadmaps = await getAllUserRoadmapsAPI(p.id);&#10;            if (userRoadmaps &amp;&amp; userRoadmaps.length &gt; 0) {&#10;                // Assuming you want the first roadmap for display&#10;                setRoadmapData(&#10;                    roadmapData.map(roadmap =&gt; ({...roadmap,user_id: p.id }) // Add user_id to each roadmap&#10;                ));&#10;                console.log(userRoadmaps);&#10;            } else {&#10;                setRoadmapData(null);&#10;            }&#10;            setLoading(false);&#10;        };&#10;        fetchRoadmap();&#10;    }, []);&#10;//&#10;    const fetchRoadmaps = async () =&gt; {&#10;        try {&#10;            setLoading(true);&#10;            &#10;            // Simulate API delay&#10;            await new Promise(resolve =&gt; setTimeout(resolve, 500));&#10;            &#10;            let filteredRoadmaps = [...roadmapData];&#10;&#10;            // Apply search filter&#10;            if (options.searchTerm) {&#10;                filteredRoadmaps = filteredRoadmaps.filter(roadmap =&gt;&#10;                    roadmap.title.toLowerCase().includes(options.searchTerm!.toLowerCase()) ||&#10;                    roadmap.description?.toLowerCase().includes(options.searchTerm!.toLowerCase())&#10;                );&#10;            }&#10;&#10;            // Apply domain filter&#10;            if (options.domain) {&#10;                filteredRoadmaps = filteredRoadmaps.filter(roadmap =&gt;&#10;                    roadmap.domain.toLowerCase() === options.domain!.toLowerCase()&#10;                );&#10;            }&#10;&#10;            // Apply sorting&#10;            if (options.sortBy) {&#10;                filteredRoadmaps.sort((a, b) =&gt; {&#10;                    const aValue = a[options.sortBy!];&#10;                    const bValue = b[options.sortBy!];&#10;                    &#10;                    if (options.sortOrder === 'desc') {&#10;                        return bValue &gt; aValue ? 1 : -1;&#10;                    }&#10;                    return aValue &gt; bValue ? 1 : -1;&#10;                });&#10;            }&#10;&#10;            setRoadmaps(filteredRoadmaps);&#10;            setError(null);&#10;        } catch (err) {&#10;            setError(err instanceof Error ? err.message : 'Failed to fetch roadmaps');&#10;        } finally {&#10;            setLoading(false);&#10;        }&#10;    };&#10;&#10;    const deleteRoadmap = async (id: number) =&gt; {&#10;        try {&#10;            // Simulate API delay&#10;            await new Promise(resolve =&gt; setTimeout(resolve, 300));&#10;            &#10;            setRoadmaps(prev =&gt; prev.filter(roadmap =&gt; roadmap.id !== id));&#10;        } catch (err) {&#10;            setError(err instanceof Error ? err.message : 'Failed to delete roadmap');&#10;        }&#10;    };&#10;&#10;    const duplicateRoadmap = async (id: number) =&gt; {&#10;        try {&#10;            // Simulate API delay&#10;            await new Promise(resolve =&gt; setTimeout(resolve, 300));&#10;            &#10;            const roadmapToDuplicate = roadmaps.find(r =&gt; r.id === id);&#10;            if (roadmapToDuplicate) {&#10;                const newRoadmap: Roadmap = {&#10;                    ...roadmapToDuplicate,&#10;                    id: Math.max(...roadmaps.map(r =&gt; r.id)) + 1,&#10;                    title: `${roadmapToDuplicate.title} (Copy)`,&#10;                    status: 'Draft',&#10;                    created_at: new Date().toISOString(),&#10;                    progress: 0,&#10;                };&#10;                setRoadmaps(prev =&gt; [...prev, newRoadmap]);&#10;            }&#10;        } catch (err) {&#10;            setError(err instanceof Error ? err.message : 'Failed to duplicate roadmap');&#10;        }&#10;    };&#10;&#10;    useEffect(() =&gt; {&#10;        fetchRoadmaps();&#10;    }, [options.searchTerm, options.domain, options.sortBy, options.sortOrder]);&#10;&#10;    return {&#10;        roadmaps,&#10;        loading,&#10;        error,&#10;        refetch: fetchRoadmaps,&#10;        deleteRoadmap,&#10;        duplicateRoadmap,&#10;    };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>